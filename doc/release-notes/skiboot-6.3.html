
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>skiboot-6.3 &#8212; skiboot 326a466
 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="skiboot-6.3-rc1" href="skiboot-6.3-rc1.html" />
    <link rel="prev" title="skiboot-6.2.4" href="skiboot-6.2.4.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="skiboot-6.3-rc1.html" title="skiboot-6.3-rc1"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="skiboot-6.2.4.html" title="skiboot-6.2.4"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">skiboot 326a466
 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Release Notes</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">skiboot-6.3</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="skiboot-6-3">
<span id="id1"></span><h1>skiboot-6.3<a class="headerlink" href="#skiboot-6-3" title="Permalink to this headline">¶</a></h1>
<p>skiboot v6.3 was released on Friday May 3rd 2019. It is the first
release of skiboot 6.3, which becomes the new stable release
of skiboot following the 6.2 release, first released December 14th 2018.</p>
<p>Skiboot 6.3 will mark the basis for op-build v2.3.</p>
<p>skiboot v6.3 contains all bug fixes as of <a class="reference internal" href="skiboot-6.0.20.html#skiboot-6-0-20"><span class="std std-ref">skiboot-6.0.20</span></a>,
and <a class="reference internal" href="skiboot-6.2.3.html#skiboot-6-2-3"><span class="std std-ref">skiboot-6.2.3</span></a> (the currently maintained
stable releases).</p>
<p>For how the skiboot stable releases work, see <a class="reference internal" href="../process/stable-skiboot-rules.html#stable-rules"><span class="std std-ref">Skiboot stable tree rules and releases</span></a> for details.</p>
<p>Over skiboot 6.2, we have the following changes:</p>
<section id="new-features">
<span id="skiboot-6-3-new-features"></span><h2>New Features<a class="headerlink" href="#new-features" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>hw/imc: Enable opal calls to init/start/stop IMC Trace mode</p>
<p>New OPAL APIs for In-Memory Collection Counter infrastructure(IMC),
including a new device type called OPAL_IMC_COUNTERS_TRACE.</p>
</li>
<li><p>xive: Add calls to save/restore the queues and VPs HW state</p>
<p>To be able to support migration of guests using the XIVE native
exploitation mode, (where the queue is effectively owned by the
guest), KVM needs to be able to save and restore the HW-modified
fields of the queue, such as the current queue producer pointer and
generation bit, and to retrieve the modified thread context registers
of the VP from the NVT structure : the VP interrupt pending bits.</p>
<p>However, there is no need to set back the NVT structure on P9. P10
should be the same.</p>
</li>
<li><p>witherspoon: Add nvlink2 interconnect information</p>
<p>GPUs on Redbud and Sequoia platforms are interconnected in groups of
2 or 3 GPUs. The problem with that is if the user decides to pass a single
GPU from a group to the userspace, we need to ensure that links between
GPUs do not get enabled.</p>
<p>A V100 GPU provides a way to disable selected links. In order to only
disable links to peer GPUs, we need a topology map.</p>
<p>This adds an “ibm,nvlink-peers” property to a GPU DT node with phandles
of peer GPUs and NVLink2 bridges. The index in the property is a GPU link
number.</p>
</li>
<li><p>platforms/romulus: Also support talos</p>
<p>The two are similar enough and I’d like to have a slot table for our
Talos.</p>
</li>
<li><p>OpenCAPI support! (see <a class="reference internal" href="#skiboot-6-3-opencapi"><span class="std std-ref">OpenCAPI</span></a> section)</p></li>
<li><p>opal/hmi: set a flag to inform OS that TOD/TB has failed.</p>
<p>Set a flag to indicate OS about TOD/TB failure as part of new
opal_handle_hmi2 handler. This flag then can be used by OS to make sure
functions depending on TB value (e.g. udelay()) are aware of TB not
ticking.</p>
</li>
<li><p>astbmc: Enable IPMI HIOMAP for AMI platforms</p>
<p>Required for Habanero, Palmetto and Romulus.</p>
</li>
<li><p>power-mgmt : occ : Add ‘freq-domain-mask’ DT property</p>
<p>Add a new device-tree property freq-domain-indicator to define group of
CPUs which would share same frequency. This property has been added under
power-mgmt node. It is a bitmask.</p>
<p>Bitwise AND is taken between this bitmask value and PIR of cpu. All the
CPUs lying in the same frequency domain will have same result for AND.</p>
<p>For example, For POWER9, 0xFFF0 indicates quad wide frequency domain.
Taking AND with the PIR of CPUs will yield us frequency domain which is
quad wise distribution as last 4 bits have been masked which represent the
cores.</p>
<p>Similarly, 0xFFF8 will represent core wide frequency domain for P8.</p>
<p>Also, Add a new device-tree property domain-runs-at which will denote the
strategy OCC is using to change the frequency of a frequency-domain. There
can be two strategy - FREQ_MOST_RECENTLY_SET and FREQ_MAX_IN_DOMAIN.</p>
<p>FREQ_MOST_RECENTLY_SET : the OCC sets the frequency of the quad to the most
recent frequency value requested by the CPUs in the quad.</p>
<p>FREQ_MAX_IN_DOMAIN : the OCC sets the frequency of the CPUs in
the Quad to the maximum of the latest frequency requested by each of
the component cores.</p>
</li>
<li><p>powercap: occ: Fix the powercapping range allowed for user</p>
<p>OCC provides two limits for minimum powercap. One being hard powercap
minimum which is guaranteed by OCC and the other one is a soft
powercap minimum which is lesser than hard-min and may or may not be
asserted due to various power-thermal reasons. So to allow the users
to access the entire powercap range, this patch exports soft powercap
minimum as the “powercap-min” DT property. And it also adds a new
DT property called “powercap-hard-min” to export the hard-min powercap
limit.</p>
</li>
<li><p>Add NVDIMM support</p>
<p>NVDIMMs are memory modules that use a battery backup system to allow the
contents RAM to be saved to non-volatile storage if system power goes
away unexpectedly. This allows them to be used a high-performance
storage device, suitable for serving as a cache for SSDs and the like.</p>
<p>Configuration of NVDIMMs is handled by hostboot and communicated to OPAL
via the HDAT. We need to parse out the NVDIMM memory ranges and create
memory regions with the “pmem-region” compatible label to make them
available to the host.</p>
</li>
<li><p>core/exceptions: implement support for MCE interrupts in powersave</p>
<p>The ISA specifies that MCE interrupts in power saving modes will enter
at 0x200 with powersave bits in SRR1 set. This is not currently
supported properly, the MCE will just happen like a normal interrupt,
but GPRs could be lost, which would lead to crashes (e.g., r1, r2, r13
etc).</p>
<p>So check the power save bits similarly to the sreset vector, and
handle this properly.</p>
</li>
<li><p>core/exceptions: allow recoverable sreset exceptions</p>
<p>This requires implementing the MSR[RI] bit. Then just allow all
non-fatal sreset exceptions to recover.</p>
</li>
<li><p>core/exceptions: implement an exception handler for non-powersave sresets</p>
<p>Detect non-powersave sresets and send them to the normal exception
handler which prints registers and stack.</p>
</li>
<li><p>Add PVR_TYPE_P9P</p>
<p>Enable a new PVR to get us running on another p9 variant.</p>
</li>
</ul>
<p>Since v6.3-rc2:</p>
<ul>
<li><p>Expose PNOR Flash partitions to host MTD driver via devicetree</p>
<p>This makes it possible for the host to directly address each
partition without requiring each application to directly parse
the FFS headers.  This has been in use for some time already to
allow BOOTKERNFW partition updates from the host.</p>
<p>All partitions except BOOTKERNFW are marked readonly.</p>
<p>The BOOTKERNFW partition is currently exclusively used by the TalosII platform</p>
</li>
<li><p>Write boot progress to LPC port 80h</p>
<p>This is an adaptation of what we currently do for op_display() on FSP
machines, inventing an encoding for what we can write into the single
byte at LPC port 80h.</p>
<p>Port 80h is often used on x86 systems to indicate boot progress/status
and dates back a decent amount of time. Since a byte isn’t exactly very
expressive for everything that can go on (and wrong) during boot, it’s
all about compromise.</p>
<p>Some systems (such as Zaius/Barreleye G2) have a physical dual 7 segment
display that display these codes. So far, this has only been driven by
hostboot (see hostboot commit 90ec2e65314c).</p>
</li>
<li><p>Write boot progress to LPC ports 81 and 82</p>
<p>There’s a thought to write more extensive boot progress codes to LPC
ports 81 and 82 to supplement/replace any reliance on port 80.</p>
<p>We want to still emit port 80 for platforms like Zaius and Barreleye
that have the physical display. Ports 81 and 82 can be monitored by a
BMC though.</p>
</li>
<li><p>Add Talos II platform</p>
<p>Talos II has some hardware differences from Romulus, therefore
we cannot guarantee Talos II == Romulus in skiboot.  Copy and
slightly modify the Romulus files for Talos II.</p>
</li>
</ul>
<p>Since v6.3-rc1:</p>
<ul>
<li><p>cpufeatures: Add tm-suspend-hypervisor-assist and tm-suspend-xer-so-bug node</p>
<p>tm-suspend-hypervisor-assist for P9 &gt;=DD2.2
And a tm-suspend-xer-so-bug node for P9 DD2.2 only.</p>
<p>I also treat P9P as P9 DD2.3 and add a unit test for the cpufeatures
infrastructure.</p>
<p>Fixes: <a class="reference external" href="https://github.com/open-power/skiboot/issues/233">https://github.com/open-power/skiboot/issues/233</a></p>
</li>
</ul>
</section>
<section id="deprecated-removed-features">
<h2>Deprecated/Removed Features<a class="headerlink" href="#deprecated-removed-features" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>opal: Deprecate reading the PHB status</p>
<p>The OPAL_PCI_EEH_FREEZE_STATUS call takes a bunch of parameters, one of
them is &#64;phb_status. It is defined as __be64* and always NULL in
the current Linux upstream but if anyone ever decides to read that status,
then the PHB3’s handler will assume it is struct OpalIoPhb3ErrorData*
(which is a lot bigger than 8 bytes) and zero it causing the stack
corruption; p7ioc-phb has the same issue.</p>
<p>This removes &#64;phb_status from all eeh_freeze_status() hooks and moves
the error message from PHB4 to the affected OPAL handlers.</p>
<p>As far as we can tell, nobody has ever used this and thus it’s safe to remove.</p>
</li>
<li><p>Remove POWER9N DD1 support</p>
<p>This is not a shipping product and is no longer supported by Linux
or other firmware components.</p>
</li>
</ul>
<p>Since v6.3-rc3:</p>
<ul>
<li><p>Disable fast-reset for POWER8</p>
<p>There is a bug with fast-reset when CPU cores are busy, which can be
reproduced by running <cite>stress</cite> and then trying <cite>reboot -ff</cite> (this is
what the op-test test cases FastRebootHostStress and
FastRebootHostStressTorture do). What happens is the cores lock up,
which isn’t the best thing in the world when you want them to start
executing instructions again.</p>
<p>A workaround is to use instruction ramming, which while greatly
increasing the reliability of fast-reset on p8, doesn’t make it perfect.</p>
<p>Instruction ramming is what pdbg was modified to do in order to have the
sreset functionality work reliably on p8.
pdbg patches: <a class="reference external" href="https://patchwork.ozlabs.org/project/pdbg/list/?series=96593&amp;state=*">https://patchwork.ozlabs.org/project/pdbg/list/?series=96593&amp;state=*</a></p>
<p>Fixes: <a class="reference external" href="https://github.com/open-power/skiboot/issues/185">https://github.com/open-power/skiboot/issues/185</a></p>
</li>
</ul>
</section>
<section id="general">
<h2>General<a class="headerlink" href="#general" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>core/i2c: Various bits of refactoring</p></li>
<li><p>refactor backtrace generation infrastructure</p></li>
<li><p>astbmc: Handle failure to initialise raw flash</p>
<p>Initialising raw flash lead to a dead assignment to rc. Check the return
code and take the failure path as necessary. Both before and after the
fix we see output along the lines of the following when flash_init()
fails:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span>   <span class="mf">53.283182881</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span> <span class="n">IRQ</span><span class="p">:</span> <span class="n">Registering</span> <span class="mf">0800..0</span><span class="n">ff7</span> <span class="n">ops</span> <span class="o">@</span><span class="mh">0x300d4b98</span> <span class="p">(</span><span class="n">data</span> <span class="mh">0x3052b9d8</span><span class="p">)</span>
<span class="p">[</span>   <span class="mf">53.283184335</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span> <span class="n">IRQ</span><span class="p">:</span> <span class="n">Registering</span> <span class="mi">0</span><span class="n">ff8</span><span class="o">.</span><span class="mf">.0</span><span class="n">fff</span> <span class="n">ops</span> <span class="o">@</span><span class="mh">0x300d4bc8</span> <span class="p">(</span><span class="n">data</span> <span class="mh">0x3052b9d8</span><span class="p">)</span>
<span class="p">[</span>   <span class="mf">53.283185513</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span> <span class="n">PHB</span><span class="c1">#0000: Initializing PHB...</span>
<span class="p">[</span>   <span class="mf">53.288260827</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="n">FLASH</span><span class="p">:</span> <span class="n">Can</span><span class="s1">&#39;t load resource id:0. No system flash found</span>
<span class="p">[</span>   <span class="mf">53.288354442</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="n">FLASH</span><span class="p">:</span> <span class="n">Can</span><span class="s1">&#39;t load resource id:1. No system flash found</span>
<span class="p">[</span>   <span class="mf">53.342933439</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="n">CAPP</span><span class="p">:</span> <span class="n">Error</span> <span class="n">loading</span> <span class="n">ucode</span> <span class="n">lid</span><span class="o">.</span> <span class="n">index</span><span class="o">=</span><span class="mi">200</span><span class="n">ea</span>
<span class="p">[</span>   <span class="mf">53.462749486</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="n">NVRAM</span><span class="p">:</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">load</span>
<span class="p">[</span>   <span class="mf">53.462819095</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="n">NVRAM</span><span class="p">:</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">load</span>
<span class="p">[</span>   <span class="mf">53.462894236</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="n">NVRAM</span><span class="p">:</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">load</span>
<span class="p">[</span>   <span class="mf">53.462967071</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="n">NVRAM</span><span class="p">:</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">load</span>
<span class="p">[</span>   <span class="mf">53.463033077</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="n">NVRAM</span><span class="p">:</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">load</span>
<span class="p">[</span>   <span class="mf">53.463144847</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="n">NVRAM</span><span class="p">:</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">load</span>
</pre></div>
</div>
<p>Eventually followed by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[   57.216942479,5] INIT: platform wait for kernel load failed
[   57.217051132,5] INIT: Assuming kernel at 0x20000000
[   57.217127508,3] INIT: ELF header not found. Assuming raw binary.
[   57.217249886,2] NVRAM: Failed to load
[   57.221294487,0] FATAL: Kernel is zeros, can&#39;t execute!
[   57.221397429,0] Assert fail: core/init.c:615:0
[   57.221471414,0] Aborting!
CPU 0028 Backtrace:
 S: 0000000031d43c60 R: 000000003001b274   ._abort+0x4c
 S: 0000000031d43ce0 R: 000000003001b2f0   .assert_fail+0x34
 S: 0000000031d43d60 R: 0000000030014814   .load_and_boot_kernel+0xae4
 S: 0000000031d43e30 R: 0000000030015164   .main_cpu_entry+0x680
 S: 0000000031d43f00 R: 0000000030002718   boot_entry+0x1c0
 --- OPAL boot ---
</pre></div>
</div>
<p>Analysis of the execution paths suggests we’ll always “safely” end this
way due the setup sequence for the blocklevel callbacks in flash_init()
and error handling in blocklevel_get_info(), and there’s no current risk
of executing from unexpected memory locations. As such the issue is
reduced to down to a fix for poor error hygene in the original change
and a resolution for a Coverity warning (famous last words etc).</p>
</li>
<li><p>core/flash: Retry requests as necessary in flash_load_resource()</p>
<p>We would like to successfully boot if we have a dependency on the BMC
for flash even if the BMC is not current ready to service flash
requests. On the assumption that it will become ready, retry for several
minutes to cover a BMC reboot cycle and <em>eventually</em> rather than
<em>immediately</em> crash out with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[  269.549748] reboot: Restarting system
[  390.297462587,5] OPAL: Reboot request...
[  390.297737995,5] RESET: Initiating fast reboot 1...
[  391.074707590,5] Clearing unused memory:
[  391.075198880,5] PCI: Clearing all devices...
[  391.075201618,7] Clearing region 201ffe000000-201fff800000
[  391.086235699,5] PCI: Resetting PHBs and training links...
[  391.254089525,3] FFS: Error 17 reading flash header
[  391.254159668,3] FLASH: Can&#39;t open ffs handle: 17
[  392.307245135,5] PCI: Probing slots...
[  392.363723191,5] PCI Summary:
...
[  393.423255262,5] OCC: All Chip Rdy after 0 ms
[  393.453092828,5] INIT: Starting kernel at 0x20000000, fdt at
0x30800a88 390645 bytes
[  393.453202605,0] FATAL: Kernel is zeros, can&#39;t execute!
[  393.453247064,0] Assert fail: core/init.c:593:0
[  393.453289682,0] Aborting!
CPU 0040 Backtrace:
 S: 0000000031e03ca0 R: 000000003001af60   ._abort+0x4c
 S: 0000000031e03d20 R: 000000003001afdc   .assert_fail+0x34
 S: 0000000031e03da0 R: 00000000300146d8   .load_and_boot_kernel+0xb30
 S: 0000000031e03e70 R: 0000000030026cf0   .fast_reboot_entry+0x39c
 S: 0000000031e03f00 R: 0000000030002a4c   fast_reset_entry+0x2c
 --- OPAL boot ---
</pre></div>
</div>
<p>The OPAL flash API hooks directly into the blocklevel layer, so there’s
no delay for e.g. the host kernel, just for asynchronously loaded
resources during boot.</p>
</li>
<li><p>fast-reboot: occ: Call occ_pstates_init() on fast-reset on all machines</p>
<p>Commit 815417dcda2e (“init, occ: Initialise OCC earlier on BMC systems”)
conditionally invoked occ_pstates_init() only on FSP based systems in
load_and_boot_kernel(). Due to this pstate table is re-parsed on FSP
system and skipped on BMC system during fast-reboot. So this patch fixes
this by invoking occ_pstates_init() on all boxes during fast-reboot.</p>
</li>
<li><p>opal/hmi: Don’t retry TOD recovery if it is already in failed state.</p>
<p>On TOD failure, all cores/thread receives HMI and very first thread that
gets interrupt fixes the TOD where as others just resets the respective
HMER error bit and return. But when TOD is unrecoverable, all the threads
try to do TOD recovery one by one causing threads to spend more time inside
opal. Set a global flag when TOD is unrecoverable so that rest of the
threads go back to linux immediately avoiding lock ups in system
reboot/panic path.</p>
</li>
<li><p>hw/bt: Do not disable ipmi message retry during OPAL boot</p>
<p>Currently OPAL doesn’t know whether BMC is functioning or not. If BMC is
down (like BMC reboot), then we keep on retry sending message to BMC. So
in some corner cases we may hit hard lockup issue in kernel.</p>
<p>Ideally we should avoid using synchronous path as much as possible. But
for now commit 01f977c3 added option to disable message retry in synchronous.
But this fix is not required during boot. Hence lets disable IPMI message
retry during OPAL boot.</p>
</li>
<li><p>hdata/memory: Fix warning message</p>
<p>Even though we added memory to device tree, we are getting below warning.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span>   <span class="mf">57.136949696</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="n">Unable</span> <span class="n">to</span> <span class="n">use</span> <span class="n">memory</span> <span class="nb">range</span> <span class="mi">0</span> <span class="kn">from</span> <span class="nn">MSAREA</span> <span class="mi">0</span>
<span class="p">[</span>   <span class="mf">57.137049753</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="n">Unable</span> <span class="n">to</span> <span class="n">use</span> <span class="n">memory</span> <span class="nb">range</span> <span class="mi">0</span> <span class="kn">from</span> <span class="nn">MSAREA</span> <span class="mi">1</span>
<span class="p">[</span>   <span class="mf">57.137152335</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="n">Unable</span> <span class="n">to</span> <span class="n">use</span> <span class="n">memory</span> <span class="nb">range</span> <span class="mi">0</span> <span class="kn">from</span> <span class="nn">MSAREA</span> <span class="mi">2</span>
<span class="p">[</span>   <span class="mf">57.137251218</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="n">Unable</span> <span class="n">to</span> <span class="n">use</span> <span class="n">memory</span> <span class="nb">range</span> <span class="mi">0</span> <span class="kn">from</span> <span class="nn">MSAREA</span> <span class="mi">3</span>
</pre></div>
</div>
</li>
<li><p>hw/bt: Add backend interface to disable ipmi message retry option</p>
<p>During boot OPAL makes IPMI_GET_BT_CAPS call to BMC to get BT interface
capabilities which includes IPMI message max resend count, message
timeout, etc,. Most of the time OPAL gets response from BMC within
specified timeout. In some corner cases (like mboxd daemon reset in BMC,
BMC reboot, etc) OPAL may not get response within timeout period. In
such scenarios, OPAL resends message until max resend count reaches.</p>
<p>OPAL uses synchronous IPMI message (ipmi_queue_msg_sync()) for few
operations like flash read, write, etc. Thread will wait in OPAL until
it gets response from BMC. In some corner cases like BMC reboot, thread
may wait in OPAL for long time (more than 20 seconds) and results in
kernel hardlockup.</p>
<p>This patch introduces new interface to disable message resend option. We
will disable message resend option for synchrous message. This will
greatly reduces kernel hardlock up issues.</p>
<p>This is short term fix. Long term solution is to convert all synchronous
messages to asynhrounous one.</p>
</li>
<li><p>ipmi/power: Fix system reboot issue</p>
<p>Kernel makes reboot/shudown OPAL call for reboot/shutdown. Once kernel
gets response from OPAL it runs opal_poll_events() until firmware
handles the request.</p>
<p>On BMC based system, OPAL makes IPMI call (IPMI_CHASSIS_CONTROL) to
initiate system reboot/shutdown. At present OPAL queues IPMI messages
and return SUCESS to Host. If BMC is not ready to accept command (like
BMC reboot), then these message will fail. We have to manually
reboot/shutdown the system using BMC interface.</p>
<p>This patch adds logic to validate message return value. If message failed,
then it will resend the message. At some stage BMC will be ready to accept
message and handles IPMI message.</p>
</li>
<li><p>firmware-versions: Add test case for parsing VERSION</p>
<p>Also make it possible to use with afl-lop/afl-fuzz just to help make
<em>sure</em> we’re all good.</p>
<p>Additionally, if we hit a entry in VERSION that is larger than our
buffer size, we skip over it gracefully rather than overwriting the
stack. This is only a problem if VERSION isn’t trusted, which as of
4b8cc05a94513816d43fb8bd6178896b430af08f it is verified as part of
Secure Boot.</p>
</li>
<li><p>core/fast-reboot: improve NMI handling during fast reset</p>
<p>Improve sreset and MCE handling in fast reboot. Switch the HILE bit
off before copying OPAL’s exception vectors, so NMIs can be handled
properly. Also disable MSR[ME] while the vectors are being overwritten</p>
</li>
<li><p>core/cpu: HID update race</p>
<p>If the per-core HID register is updated concurrently by multiple
threads, updates can get lost. This has been observed during fast
reboot where the HILE bit does not get cleared on all cores, which
can cause machine check exception interrupts to crash.</p>
<p>Fix this by only updating HID on thread0.</p>
</li>
<li><p>SLW: Print verbose info on errors only</p>
<p>Change print level from debug to warning for reporting
bad EC_PPM_SPECIAL_WKUP_* scom values. To reduce cluttering
in the log print only on error.</p>
</li>
</ul>
<p>Since v6.3-rc2:</p>
<ul>
<li><p>hw/xscom: add missing P9P chip name</p></li>
<li><p>asm/head: balance branches to avoid link stack predictor mispredicts</p>
<p>The Linux wrapper for OPAL call and return is arranged like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__opal_call</span><span class="p">:</span>
    <span class="n">mflr</span>   <span class="n">r0</span>
    <span class="n">std</span>    <span class="n">r0</span><span class="p">,</span><span class="n">PPC_STK_LROFF</span><span class="p">(</span><span class="n">r1</span><span class="p">)</span>
    <span class="n">LOAD_REG_ADDR</span><span class="p">(</span><span class="n">r11</span><span class="p">,</span> <span class="n">opal_return</span><span class="p">)</span>
    <span class="n">mtlr</span>   <span class="n">r11</span>
    <span class="n">hrfid</span>  <span class="o">-&gt;</span> <span class="n">OPAL</span>

<span class="n">opal_return</span><span class="p">:</span>
    <span class="n">ld</span>     <span class="n">r0</span><span class="p">,</span><span class="n">PPC_STK_LROFF</span><span class="p">(</span><span class="n">r1</span><span class="p">)</span>
    <span class="n">mtlr</span>   <span class="n">r0</span>
    <span class="n">blr</span>
</pre></div>
</div>
<p>When skiboot returns to Linux, it branches to LR (i.e., opal_return)
with a blr. This unbalances the link stack predictor and will cause
mispredicts back up the return stack.</p>
</li>
<li><p>external/mambo: also invoke readline for the non-autorun case</p></li>
<li><p>asm/head.S: set POWER9 radix HID bit at entry</p>
<p>When running in virtual memory mode, the radix MMU hid bit should not
be changed, so set this in the initial boot SPR setup.</p>
<p>As a side effect, fast reboot also has HID0:RADIX bit set by the
shared spr init, so no need for an explicit call.</p>
</li>
<li><p>build: link with –orphan-handling=warn</p>
<p>The linker can warn when the linker script does not explicitly place
all sections. These orphan sections are placed according to
heuristics, which may not always be desirable. Enable this warning.</p>
</li>
<li><p>build: -fno-asynchronous-unwind-tables</p>
<p>skiboot does not use unwind tables, this option saves about 100kB,
mostly from .text.</p>
</li>
<li><p>opal/hmi: Initialize the hmi event with old value of TFMR.</p>
<p>Do this before we fix TFAC errors. Otherwise the event at host console
shows no thread error reported in TFMR register.</p>
<p>Without this patch the console event show TFMR with no thread error:
(DEC parity error TFMR[59] injection)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span>   <span class="mf">53.737572</span><span class="p">]</span> <span class="n">Severe</span> <span class="n">Hypervisor</span> <span class="n">Maintenance</span> <span class="n">interrupt</span> <span class="p">[</span><span class="n">Recovered</span><span class="p">]</span>
<span class="p">[</span>   <span class="mf">53.737596</span><span class="p">]</span>  <span class="n">Error</span> <span class="n">detail</span><span class="p">:</span> <span class="n">Timer</span> <span class="n">facility</span> <span class="n">experienced</span> <span class="n">an</span> <span class="n">error</span>
<span class="p">[</span>   <span class="mf">53.737611</span><span class="p">]</span>  <span class="n">HMER</span><span class="p">:</span> <span class="mi">0840000000000000</span>
<span class="p">[</span>   <span class="mf">53.737621</span><span class="p">]</span>  <span class="n">TFMR</span><span class="p">:</span> <span class="mf">3212000870e04000</span>
</pre></div>
</div>
<p>After this patch it shows old TFMR value on host console:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="mf">2302.267271</span><span class="p">]</span> <span class="n">Severe</span> <span class="n">Hypervisor</span> <span class="n">Maintenance</span> <span class="n">interrupt</span> <span class="p">[</span><span class="n">Recovered</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">2302.267305</span><span class="p">]</span>  <span class="n">Error</span> <span class="n">detail</span><span class="p">:</span> <span class="n">Timer</span> <span class="n">facility</span> <span class="n">experienced</span> <span class="n">an</span> <span class="n">error</span>
<span class="p">[</span> <span class="mf">2302.267320</span><span class="p">]</span>  <span class="n">HMER</span><span class="p">:</span> <span class="mi">0840000000000000</span>
<span class="p">[</span> <span class="mf">2302.267330</span><span class="p">]</span>  <span class="n">TFMR</span><span class="p">:</span> <span class="mf">3212000870e14010</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="ibm-fsp-based-platforms">
<h2>IBM FSP based platforms<a class="headerlink" href="#ibm-fsp-based-platforms" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>platforms/firenze: Rework I2C controller fixups</p></li>
<li><p>platforms/zz: Re-enable LXVPD slot information parsing</p>
<p>From memory this was disabled in the distant past since we were waiting
for an updates to the LXPVD format. It looks like that never happened
so re-enable it for the ZZ platform so that we can get PCI slot location
codes on ZZ.</p>
</li>
</ul>
</section>
<section id="hiomap">
<h2>HIOMAP<a class="headerlink" href="#hiomap" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>astbmc: Try IPMI HIOMAP for P8</p>
<p>The HIOMAP protocol was developed after the release of P8 in preparation
for P9. As a consequence P9 always uses it, but it has rarely been
enabled for P8. P8DTU has recently added IPMI HIOMAP support to its BMC
firmware, so enable its use in skiboot with P8 machines. Doing so
requires some rework to ensure fallback works correctly as in the past
the fallback was to mbox, which will only work for P9.</p>
</li>
<li><p>libflash/ipmi-hiomap: Enforce message size for empty response</p>
<p>The protocol defines the response to the associated messages as empty
except for the command ID and sequence fields. If the BMC is returning
extra data consider the message malformed.</p>
</li>
<li><p>libflash/ipmi-hiomap: Remove unused close handling</p>
<p>Issuing a HIOMAP_C_CLOSE is not required by the protocol specification,
rather a close can be implicit in a subsequent
CREATE_{READ,WRITE}_WINDOW request. The implicit close provides an
opportunity to reduce LPC traffic and the implementation takes up that
optimisation, so remove the case from the IPMI callback handler.</p>
</li>
<li><p>libflash/ipmi-hiomap: Overhaul event handling</p>
<p>Reworking the event handling was inspired by a bug report by Vasant
where the host would get wedged on multiple flash access attempts in the
face of a persistent error state on the BMC-side. The cause of this bug
was the early-exit based on ctx-&gt;update, which erronously assumed that
all events had been completely handled in prior calls to
ipmi_hiomap_handle_events(). This is not true if e.g.
HIOMAP_E_DAEMON_READY is clear in the prior calls.</p>
<p>Regardless, there were other correctness and efficiency problems with
the handling strategy:</p>
<ul class="simple">
<li><p>Ack-able event state was not restored in the face of errors in the
process of re-establishing protocol state</p></li>
<li><p>It forced needless window restoration with respect to the context in
which ipmi_hiomap_handle_events() was called.</p></li>
<li><p>Tests for HIOMAP_E_DAEMON_READY and HIOMAP_E_FLASH_LOST were redundant
with the overhauled error handling introduced in the previous patch</p></li>
</ul>
<p>Fix all of the above issues and add comments to explain the event
handling flow.</p>
</li>
<li><p>libflash/ipmi-hiomap: Overhaul error handling</p>
<p>The aim is to improve the robustness with respect to absence of the
BMC-side daemon. The current error handling roughly mirrors what was
done for the mailbox implementation, but there’s room for improvement.</p>
<p>Errors are split into two classes, those that affect the transport state
and those that affect the window validity. From here, we push the
transport state error checks right to the bottom of the stack, to ensure
the link is known to be in a good state before any message is sent.
Window validity tests remain as they were in the hiomap_window_move()
and ipmi_hiomap_read() functions. Validity tests are not necessary in
the write and erase paths as we will receive an error response from the
BMC when performing a dirty or flush on an invalid window.</p>
<p>Recovery also remains as it was, done on entry to the blocklevel
callbacks. If an error state is encountered in the middle of an
operation no attempt is made to recover it on the spot, instead the
error is returned up the stack and the caller can choose how it wishes
to respond.</p>
</li>
<li><p>libflash/ipmi-hiomap: Fix leak of msg in callback</p></li>
</ul>
<p>Since v6.3-rc1:</p>
<ul>
<li><p>libflash/ipmi-hiomap: Fix blocks count issue</p>
<p>We convert data size to block count and pass block count to BMC.
If data size is not block aligned then we endup sending block count
less than actual data. BMC will write partial data to flash memory.</p>
<p>Sample log</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span>  <span class="mf">594.388458416</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span> <span class="n">HIOMAP</span><span class="p">:</span> <span class="n">Marked</span> <span class="n">flash</span> <span class="n">dirty</span> <span class="n">at</span> <span class="mh">0x42010</span> <span class="k">for</span> <span class="mi">8</span>
<span class="p">[</span>  <span class="mf">594.398756487</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span> <span class="n">HIOMAP</span><span class="p">:</span> <span class="n">Flushed</span> <span class="n">writes</span>
<span class="p">[</span>  <span class="mf">594.409596439</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span> <span class="n">HIOMAP</span><span class="p">:</span> <span class="n">Marked</span> <span class="n">flash</span> <span class="n">dirty</span> <span class="n">at</span> <span class="mh">0x42018</span> <span class="k">for</span> <span class="mi">3970</span>
<span class="p">[</span>  <span class="mf">594.419897507</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span> <span class="n">HIOMAP</span><span class="p">:</span> <span class="n">Flushed</span> <span class="n">writes</span>
</pre></div>
</div>
<p>In this case HIOMAP sent data with block count=0 and hence BMC didn’t
flush data to flash.</p>
</li>
</ul>
</section>
<section id="power8">
<h2>POWER8<a class="headerlink" href="#power8" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>hw/phb3/naples: Disable D-states</p>
<p>Putting “Mellanox Technologies MT27700 Family [ConnectX-4] [15b3:1013]”
(more precisely, the second of 2 its PCI functions, no matter in what
order) into the D3 state causes EEH with the “PCT timeout” error.
This has been noticed on garrison machines only and firestones do not
seem to have this issue.</p>
<p>This disables D-states changing for devices on root buses on Naples by
installing a config space access filter (copied from PHB4).</p>
</li>
<li><p>cpufeatures: Always advertise POWER8NVL as DD2</p>
<p>Despite the major version of PVR being 1 (0x004c0100) for POWER8NVL,
these chips are functionally equalent to P8/P8E DD2 levels.</p>
<p>This advertises POWER8NVL as DD2. As the result, skiboot adds
ibm,powerpc-cpu-features/processor-control-facility for such CPUs and
the linux kernel can use hypervisor doorbell messages to wake secondary
threads; otherwise “KVM: CPU %d seems to be stuck” would appear because
of missing LPCR_PECEDH.</p>
</li>
</ul>
<section id="p8dtu-platform">
<h3>p8dtu Platform<a class="headerlink" href="#p8dtu-platform" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>p8dtu: Configure BMC graphics</p>
<p>We can no-longer read the values from the BMC in the way we have in the
past. Values were provided by Eric Chen of SMC.</p>
</li>
<li><p>p8dtu: Enable HIOMAP support</p></li>
</ul>
</section>
<section id="vesnin-platform">
<h3>Vesnin Platform<a class="headerlink" href="#vesnin-platform" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>platforms/vesnin: Disable PCIe port bifurcation</p>
<p>PCIe ports connected to CPU1 and CPU3 now work as x16 instead of x8x8.</p>
</li>
<li><p>Fix hang in pnv_platform_error_reboot path due to TOD failure.</p>
<p>On TOD failure, with TB stuck, when linux heads down to
pnv_platform_error_reboot() path due to unrecoverable hmi event, the panic
cpu gets stuck in OPAL inside ipmi_queue_msg_sync(). At this time, rest
all other cpus are in smp_handle_nmi_ipi() waiting for panic cpu to proceed.
But with panic cpu stuck inside OPAL, linux never recovers/reboot.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p0</span> <span class="n">c1</span> <span class="n">t0</span>
<span class="n">NIA</span> <span class="p">:</span> <span class="mh">0x000000003001dd3c</span> <span class="o">&lt;.</span><span class="n">time_wait</span><span class="o">+</span><span class="mh">0x64</span><span class="o">&gt;</span>
<span class="n">CFAR</span> <span class="p">:</span> <span class="mh">0x000000003001dce4</span> <span class="o">&lt;.</span><span class="n">time_wait</span><span class="o">+</span><span class="mh">0xc</span><span class="o">&gt;</span>
<span class="n">MSR</span> <span class="p">:</span> <span class="mh">0x9000000002803002</span>
<span class="n">LR</span> <span class="p">:</span> <span class="mh">0x000000003002ecf8</span> <span class="o">&lt;.</span><span class="n">ipmi_queue_msg_sync</span><span class="o">+</span><span class="mh">0xec</span><span class="o">&gt;</span>

<span class="n">STACK</span><span class="p">:</span> <span class="n">SP</span> <span class="n">NIA</span>
<span class="mh">0x0000000031c236e0</span> <span class="mh">0x0000000031c23760</span> <span class="p">(</span><span class="n">big</span><span class="o">-</span><span class="n">endian</span><span class="p">)</span>
<span class="mh">0x0000000031c23760</span> <span class="mh">0x000000003002ecf8</span> <span class="o">&lt;.</span><span class="n">ipmi_queue_msg_sync</span><span class="o">+</span><span class="mh">0xec</span><span class="o">&gt;</span>
<span class="mh">0x0000000031c237f0</span> <span class="mh">0x00000000300aa5f8</span> <span class="o">&lt;.</span><span class="n">hiomap_queue_msg_sync</span><span class="o">+</span><span class="mh">0x7c</span><span class="o">&gt;</span>
<span class="mh">0x0000000031c23880</span> <span class="mh">0x00000000300aaadc</span> <span class="o">&lt;.</span><span class="n">hiomap_window_move</span><span class="o">+</span><span class="mh">0x150</span><span class="o">&gt;</span>
<span class="mh">0x0000000031c23950</span> <span class="mh">0x00000000300ab1d8</span> <span class="o">&lt;.</span><span class="n">ipmi_hiomap_write</span><span class="o">+</span><span class="mh">0xcc</span><span class="o">&gt;</span>
<span class="mh">0x0000000031c23a90</span> <span class="mh">0x00000000300a7b18</span> <span class="o">&lt;.</span><span class="n">blocklevel_raw_write</span><span class="o">+</span><span class="mh">0xbc</span><span class="o">&gt;</span>
<span class="mh">0x0000000031c23b30</span> <span class="mh">0x00000000300a7c34</span> <span class="o">&lt;.</span><span class="n">blocklevel_write</span><span class="o">+</span><span class="mh">0xfc</span><span class="o">&gt;</span>
<span class="mh">0x0000000031c23bf0</span> <span class="mh">0x0000000030030be0</span> <span class="o">&lt;.</span><span class="n">flash_nvram_write</span><span class="o">+</span><span class="mh">0xd4</span><span class="o">&gt;</span>
<span class="mh">0x0000000031c23c90</span> <span class="mh">0x000000003002c128</span> <span class="o">&lt;.</span><span class="n">opal_write_nvram</span><span class="o">+</span><span class="mh">0xd0</span><span class="o">&gt;</span>
<span class="mh">0x0000000031c23d20</span> <span class="mh">0x00000000300051e4</span> <span class="o">&lt;</span><span class="n">opal_entry</span><span class="o">+</span><span class="mh">0x134</span><span class="o">&gt;</span>
<span class="mh">0xc000001fea6e7870</span> <span class="mh">0xc0000000000a9060</span> <span class="o">&lt;</span><span class="n">opal_nvram_write</span><span class="o">+</span><span class="mh">0x80</span><span class="o">&gt;</span>
<span class="mh">0xc000001fea6e78c0</span> <span class="mh">0xc000000000030b84</span> <span class="o">&lt;</span><span class="n">nvram_write_os_partition</span><span class="o">+</span><span class="mh">0x94</span><span class="o">&gt;</span>
<span class="mh">0xc000001fea6e7960</span> <span class="mh">0xc0000000000310b0</span> <span class="o">&lt;</span><span class="n">nvram_pstore_write</span><span class="o">+</span><span class="mh">0xb0</span><span class="o">&gt;</span>
<span class="mh">0xc000001fea6e7990</span> <span class="mh">0xc0000000004792d4</span> <span class="o">&lt;</span><span class="n">pstore_dump</span><span class="o">+</span><span class="mh">0x1d4</span><span class="o">&gt;</span>
<span class="mh">0xc000001fea6e7ad0</span> <span class="mh">0xc00000000018a570</span> <span class="o">&lt;</span><span class="n">kmsg_dump</span><span class="o">+</span><span class="mh">0x140</span><span class="o">&gt;</span>
<span class="mh">0xc000001fea6e7b40</span> <span class="mh">0xc000000000028e5c</span> <span class="o">&lt;</span><span class="n">panic_flush_kmsg_end</span><span class="o">+</span><span class="mh">0x2c</span><span class="o">&gt;</span>
<span class="mh">0xc000001fea6e7b60</span> <span class="mh">0xc0000000000a7168</span> <span class="o">&lt;</span><span class="n">pnv_platform_error_reboot</span><span class="o">+</span><span class="mh">0x68</span><span class="o">&gt;</span>
<span class="mh">0xc000001fea6e7bd0</span> <span class="mh">0xc0000000000ac9b8</span> <span class="o">&lt;</span><span class="n">hmi_event_handler</span><span class="o">+</span><span class="mh">0x1d8</span><span class="o">&gt;</span>
<span class="mh">0xc000001fea6e7c80</span> <span class="mh">0xc00000000012d6c8</span> <span class="o">&lt;</span><span class="n">process_one_work</span><span class="o">+</span><span class="mh">0x1b8</span><span class="o">&gt;</span>
<span class="mh">0xc000001fea6e7d20</span> <span class="mh">0xc00000000012da28</span> <span class="o">&lt;</span><span class="n">worker_thread</span><span class="o">+</span><span class="mh">0x88</span><span class="o">&gt;</span>
<span class="mh">0xc000001fea6e7db0</span> <span class="mh">0xc0000000001366f4</span> <span class="o">&lt;</span><span class="n">kthread</span><span class="o">+</span><span class="mh">0x164</span><span class="o">&gt;</span>
<span class="mh">0xc000001fea6e7e20</span> <span class="mh">0xc00000000000b65c</span> <span class="o">&lt;</span><span class="n">ret_from_kernel_thread</span><span class="o">+</span><span class="mh">0x5c</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>This is because, there is a while loop towards the end of
ipmi_queue_msg_sync() which keeps looping until “sync_msg” does not match
with “msg”. It loops over time_wait_ms() until exit condition is met. In
normal scenario time_wait_ms() calls run pollers so that ipmi backend gets
a chance to check ipmi response and set sync_msg to NULL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">sync_msg</span> <span class="o">==</span> <span class="n">msg</span><span class="p">)</span>
        <span class="n">time_wait_ms</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</pre></div>
</div>
<p>But in the event when TB is in failed state time_wait_ms()-&gt;time_wait_poll()
returns immediately without calling pollers and hence we end up looping
forever. This patch fixes this hang by calling opal_run_pollers() in TB
failed state as well.</p>
</li>
</ul>
</section>
</section>
<section id="power9">
<span id="skiboot-6-3-power9"></span><h2>POWER9<a class="headerlink" href="#power9" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>Retry link training at PCIe GEN1 if presence detected but training repeatedly failed</p>
<p>Certain older PCIe 1.0 devices will not train unless the training process starts at GEN1 speeds.
As a last resort when a device will not train, fall back to GEN1 speed for the last training attempt.</p>
<p>This is verified to fix devices based on the Conexant CX23888 on the Talos II platform.</p>
</li>
<li><p>hw/phb4: Drop FRESET_DEASSERT_DELAY state</p>
<p>The delay between the ASSERT_DELAY and DEASSERT_DELAY states is set to
one timebase tick. This state seems to have been a hold over from PHB3
where it was used to add a 1s delay between de-asserting PERST and
polling the link for the CAPI FPGA. There’s no requirement for that here
since the link polling on PHB4 is a bit smarter so we should be fine.</p>
</li>
<li><p>hw/phb4: Factor out PERST control</p>
<p>Some time ago Mikey added some code work around a bug we found where a
certain RAID card wouldn’t come back again after a fast-reboot. The
workaround is setting the Link Disable bit before asserting PERST and
clear it after de-asserting PERST.</p>
<p>Currently we do this in the FRESET path, but not in the CRESET path.
This patch moves the PERST control into its own function to reduce
duplication and to the workaround is applied in all circumstances.</p>
</li>
<li><p>hw/phb4: Remove FRESET presence check</p>
<p>When we do an freset the first step is to check if a card is present in
the slot. However, this only occurs when we enter phb4_freset() with the
slot state set to SLOT_NORMAL. This occurs in:</p>
<ol class="loweralpha simple">
<li><p>The creset path, and</p></li>
<li><p>When the OS manually requests an FRESET via an OPAL call.</p></li>
</ol>
<p>(a) is problematic because in the boot path the generic code will put the
slot into FRESET_START manually before calling into phb4_freset(). This
can result in a situation where a device is detected on boot, but not
after a CRESET.</p>
<p>I’ve noticed this occurring on systems where the PHB’s slot presence
detect signal is not wired to an adapter. In this situation we can rely
on the in-band presence mechanism, but the presence check will make
us exit before that has a chance to work.</p>
<p>Additionally, if we enter from the CRESET path this early exit leaves
the slot’s PERST signal being left asserted. This isn’t currently an issue,
but if we want to support hotplug of devices into the root port it will
be.</p>
</li>
<li><p>hw/phb4: Skip FRESET PERST when coming from CRESET</p>
<p>PERST is asserted at the beginning of the CRESET process to prevent
the downstream device from interacting with the host while the PHB logic
is being reset and re-initialised. There is at least a 100ms wait during
the CRESET processing so it’s not necessary to wait this time again
in the FRESET handler.</p>
<p>This patch extends the delay after re-setting the PHB logic to extend
to the 250ms PERST wait period that we typically use and sets the
skip_perst flag so that we don’t wait this time again in the FRESET
handler.</p>
</li>
<li><p>hw/phb4: Look for the hub-id from in the PBCQ node</p>
<p>The hub-id is stored in the PBCQ node rather than the stack node so we
never add it to the PHB node. This breaks the lxvpd slot lookup code
since the hub-id is encoded in the VPD record that we need to find the
slot information.</p>
</li>
<li><p>hdata/iohub: Look for IOVPD on P9</p>
<p>P8 and P9 use the same IO VPD setup, so we need to load the IOHUB VPD on
P9 systems too.</p>
</li>
</ul>
<p>Since v6.3-rc2:</p>
<ul>
<li><p>hw/phb4: Squash the IO bridge window</p>
<p>The PCI-PCI bridge spec says that bridges that implement an IO window
should hardcode the IO base and limit registers to zero.
Unfortunately, these registers only define the upper bits of the IO
window and the low bits are assumed to be 0 for the base and 1 for the
limit address. As a result, setting both to zero can be mis-interpreted
as a 4K IO window.</p>
<p>This patch fixes the problem the same way PHB3 does. It sets the IO base
and limit values to 0xf000 and 0x1000 respectively which most software
interprets as a disabled window.</p>
<p>lspci before patch:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0000</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mf">00.0</span> <span class="n">PCI</span> <span class="n">bridge</span><span class="p">:</span> <span class="n">IBM</span> <span class="n">Device</span> <span class="mi">04</span><span class="n">c1</span> <span class="p">(</span><span class="n">prog</span><span class="o">-</span><span class="k">if</span> <span class="mi">00</span> <span class="p">[</span><span class="n">Normal</span> <span class="n">decode</span><span class="p">])</span>
        <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">behind</span> <span class="n">bridge</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">00000</span><span class="n">fff</span>
</pre></div>
</div>
<p>lspci after patch:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0000</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mf">00.0</span> <span class="n">PCI</span> <span class="n">bridge</span><span class="p">:</span> <span class="n">IBM</span> <span class="n">Device</span> <span class="mi">04</span><span class="n">c1</span> <span class="p">(</span><span class="n">prog</span><span class="o">-</span><span class="k">if</span> <span class="mi">00</span> <span class="p">[</span><span class="n">Normal</span> <span class="n">decode</span><span class="p">])</span>
        <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">behind</span> <span class="n">bridge</span><span class="p">:</span> <span class="kc">None</span>
</pre></div>
</div>
</li>
<li><p>hw/xscom: Enable sw xstop by default on p9</p>
<p>This was disabled at some point during bringup to make life easier for
the lab folks trying to debug NVLink issues. This hack really should
have never made it out into the wild though, so we now have the
following situation occuring in the field:</p>
<ol class="arabic simple">
<li><p>A bad happens</p></li>
<li><p>The host kernel recieves an unrecoverable HMI and calls into OPAL to
request a platform reboot.</p></li>
<li><p>OPAL rejects the reboot attempt and returns to the kernel with
OPAL_PARAMETER.</p></li>
<li><p>Kernel panics and attempts to kexec into a kdump kernel.</p></li>
</ol>
<p>A side effect of the HMI seems to be CPUs becoming stuck which results
in the initialisation of the kdump kernel taking a extremely long time
(6+ hours). It’s also been observed that after performing a dump the
kdump kernel then crashes itself because OPAL has ended up in a bad
state as a side effect of the HMI.</p>
<p>All up, it’s not very good so re-enable the software checkstop by
default. If people still want to turn it off they can using the nvram
override.</p>
</li>
</ul>
<section id="capi2">
<h3>CAPI2<a class="headerlink" href="#capi2" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>capp/phb4: Prevent HMI from getting triggered when disabling CAPP</p>
<p>While disabling CAPP an HMI gets triggered as soon as ETU is put in
reset mode. This is caused as before we can disabled CAPP, it detects
PHB link going down and triggers an HMI requesting Opal to perform
CAPP recovery. This has an un-intended side effect of spamming the
Opal logs with malfunction alert messages and may also confuse the
user.</p>
<p>To prevent this we mask the CAPP FIR error ‘PHB Link Down’ Bit(31)
when we are disabling CAPP just before we put ETU in reset in
phb4_creset(). Also now since bringing down the PHB link now wont
trigger an HMI and CAPP recovery, hence we manually set the
PHB4_CAPP_RECOVERY flag on the phb to force recovery during creset.</p>
</li>
<li><p>phb4/capp: Implement sequence to disable CAPP and enable fast-reset</p>
<p>We implement h/w sequence to disable CAPP in disable_capi_mode() and
with it also enable fast-reset for CAPI mode in phb4_set_capi_mode().</p>
<p>Sequence to disable CAPP is executed in three phases. The first two
phase is implemented in disable_capi_mode() where we reset the CAPP
registers followed by PEC registers to their init values. The final
third final phase is to reset the PHB CAPI Compare/Mask Register and
is done in phb4_init_ioda3(). The reason to move the PHB reset to
phb4_init_ioda3() is because by the time Opal PCI reset state machine
reaches this function the PHB is already un-fenced and its
configuration registers accessible via mmio.</p>
</li>
<li><p>capp/phb4: Force CAPP to PCIe mode during kernel shutdown</p>
<p>This patch introduces a new opal syncer for PHB4 named
phb4_host_sync_reset(). We register this opal syncer when CAPP is
activated successfully in phb4_set_capi_mode() so that it will be
called at kernel shutdown during fast-reset.</p>
<p>During kernel shutdown the function will then repeatedly call
phb-&gt;ops-&gt;set_capi_mode() to switch switch CAPP to PCIe mode. In case
set_capi_mode() indicates its OPAL_BUSY, which indicates that CAPP is
still transitioning to new state; it calls slot-&gt;ops.run_sm() to
ensure that Opal slot reset state machine makes forward progress.</p>
</li>
</ul>
</section>
<section id="witherspoon-platform">
<h3>Witherspoon Platform<a class="headerlink" href="#witherspoon-platform" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>platforms/witherspoon: Make PCIe shared slot error message more informative</p>
<p>If we’re missing chips for some reason, we print a warning when configuring
the PCIe shared slot.</p>
<p>The warning doesn’t really make it clear what “shared slot” is, and if it’s
printed, it’ll come right after a bunch of messages about NPU setup, so
let’s clarify the message to explicitly mention PCI.</p>
</li>
<li><p>witherspoon: Add nvlink2 interconnect information</p>
<p>See <a class="reference internal" href="#skiboot-6-3-new-features"><span class="std std-ref">New Features</span></a> for details.</p>
</li>
</ul>
</section>
<section id="zaius-platform">
<h3>Zaius Platform<a class="headerlink" href="#zaius-platform" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>zaius: Add BMC description</p>
<p>Frederic reported that Zaius was failing with a NULL dereference when
trying to initialise IPMI HIOMAP. It turns out that the BMC wasn’t
described at all, so add a description.</p>
</li>
</ul>
</section>
<section id="p9dsu-platform">
<h3>p9dsu platform<a class="headerlink" href="#p9dsu-platform" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>p9dsu: Fix p9dsu default variant</p>
<p>Add the default when no riser_id is returned from the ipmi query.</p>
<p>Allow a little more time for BMC reply and cleanup some label strings.</p>
</li>
</ul>
</section>
</section>
<section id="pcie">
<h2>PCIe<a class="headerlink" href="#pcie" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="#skiboot-6-3-power9"><span class="std std-ref">POWER9</span></a> for POWER9 specific PCIe changes.</p>
<ul>
<li><p>core/pcie-slot: Don’t bail early in the power on case</p>
<p>Exiting early in the power off case makes sense since we can’t disable
slot power (or assert PERST) for suprise hotplug slots. However, we
should not exit early in the power-on case since it’s possible slot
power may have been disabled (or just not enabled at boot time).</p>
</li>
<li><p>firenze-pci: Always init slot info from LXVPD</p>
<p>We can slot information from the LXVPD without having power control
information about that slot. This patch changes the init path so that
we always override the add_properties() call rather than only when we
have power control information about the slot.</p>
</li>
<li><p>fsp/lxvpd: Print more LXVPD slot information</p>
<p>Useful to know since it changes the behaviour of the slot core.</p>
</li>
<li><p>core/pcie-slot: Set power state from the PWRCTL flag</p>
<p>For some reason we look at the power control indicator and use that to
determine if the slot is “off” rather than the power control flag that
is used to power down the slot.</p>
<p>While we’re here change the default behaviour so that the slot is
assumed to be powered on if there’s no slot capability, or if there’s
no power control available.</p>
</li>
<li><p>core/pci: Increase the max slot string size</p>
<p>The maximum string length for the slot label / device location code in
the PCI summary is currently 32 characters. This results in some IBM
location codes being truncated due to their length, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PHB</span><span class="c1">#0001:02:11.0 [SWDN]  SLOT=C11  x8</span>
<span class="n">PHB</span><span class="c1">#0001:13:00.0 [EP  ] *snip* LOC_CODE=U78D3.ND1.WZS004A-P1-C</span>
<span class="n">PHB</span><span class="c1">#0001:13:00.1 [EP  ] *snip* LOC_CODE=U78D3.ND1.WZS004A-P1-C</span>
<span class="n">PHB</span><span class="c1">#0001:13:00.2 [EP  ] *snip* LOC_CODE=U78D3.ND1.WZS004A-P1-C</span>
<span class="n">PHB</span><span class="c1">#0001:13:00.3 [EP  ] *snip* LOC_CODE=U78D3.ND1.WZS004A-P1-C</span>
</pre></div>
</div>
<p>Which obscure the actual location of the card, and it looks bad. This
patch increases the maximum length of the label string to 80 characters
since that’s the maximum length for a location code.</p>
</li>
</ul>
<p>Since v6.3-rc3:</p>
<ul>
<li><p>pci: Try harder to add meaningful ibm,loc-code</p>
<p>We keep the existing logic of looking to the parent for the slot-label or
slot-location-code, but we add logic to (if all that fails) we look
directly for the slot-location-code (as this should give us the correct
loc code for things directly under the PHB), and otherwise we just look
for a loc-code.</p>
<p>The applicable bit of PAPR here is:</p>
<blockquote>
<div><p>R1–12.1–1. Each instance of a hardware entity (FRU) has a platform
unique location code and any node in the OF
device tree that describes a part of a hardware entity must include the
“ibm,loc-code” property with a
value that represents the location code for that hardware entity.</p>
</div></blockquote>
<p>which we weren’t really fully obeying at any recent (ever?) point in
time. Now we should do okay, at least for PCI.</p>
</li>
</ul>
<p>Since v6.3-rc2:
- core/pci: Use PHB io-base-location by default for PHB slots</p>
<blockquote>
<div><p>On witherspoon only the GPU slots and the three pluggable PCI slots
(SLOT0, 1, 2) have platform defined slot names. For builtin devices such
as the SATA controller or the PLX switch that fans out to the GPU slots
we have no location codes which some people consider an issue.</p>
<p>This patch address the problem by making the ibm,slot-location-code for
the root port device default to the ibm,io-base-location-code which is
typically the location code for the system itself.</p>
<p>e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pciex</span><span class="o">@</span><span class="mi">600</span><span class="n">c3c0100000</span><span class="o">/</span><span class="n">ibm</span><span class="p">,</span><span class="n">loc</span><span class="o">-</span><span class="n">code</span>
                 <span class="s2">&quot;UOPWR.0000000-Node0-Proc0&quot;</span>

<span class="n">pciex</span><span class="o">@</span><span class="mi">600</span><span class="n">c3c0100000</span><span class="o">/</span><span class="n">pci</span><span class="o">@</span><span class="mi">0</span><span class="o">/</span><span class="n">ibm</span><span class="p">,</span><span class="n">loc</span><span class="o">-</span><span class="n">code</span>
                 <span class="s2">&quot;UOPWR.0000000-Node0-Proc0&quot;</span>

<span class="n">pciex</span><span class="o">@</span><span class="mi">600</span><span class="n">c3c0100000</span><span class="o">/</span><span class="n">pci</span><span class="o">@</span><span class="mi">0</span><span class="o">/</span><span class="n">usb</span><span class="o">-</span><span class="n">xhci</span><span class="o">@</span><span class="mi">0</span><span class="o">/</span><span class="n">ibm</span><span class="p">,</span><span class="n">loc</span><span class="o">-</span><span class="n">code</span>
                 <span class="s2">&quot;UOPWR.0000000-Node0&quot;</span>
</pre></div>
</div>
<p>The PHB node, and the root complex nodes have a loc code of the
processor they are attached to, while the usb-xhci device under the
root port has a location code of the system itself.</p>
</div></blockquote>
<ul>
<li><p>hw/phb4: Read ibm,loc-code from PBCQ node</p>
<p>On P9 the PBCQs are subdivided by stacks which implement the PCI Express
logic. When phb4 was forked from phb3 most of the properties that were
in the pbcq node moved into the stack node, but ibm,loc-code was not one
of them. This patch fixes the phb4 init sequence to read the base
location code from the PBCQ node (parent of the stack node) rather than
the stack node itself.</p>
</li>
</ul>
</section>
<section id="opencapi">
<span id="skiboot-6-3-opencapi"></span><h2>OpenCAPI<a class="headerlink" href="#opencapi" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>npu2/hw-procedures: Fix parallel zcal for opencapi</p>
<p>For opencapi, we currently do impedance calibration when initializing
the PHY for the device, which could run in parallel if we have
multiple opencapi devices. But if 2 devices are on the same
obus, the 2 calibration sequences could overlap, which likely yields
bad results and is useless anyway since it only needs to be done once
per obus.</p>
<p>This patch splits the opencapi PHY reset in 2 parts:</p>
<ul class="simple">
<li><p>a ‘init’ part called serially at boot. That’s when zcal is done. If
we have 2 devices on the same socket, the zcal won’t be redone,
since we’re called serially and we’ll see it has already be done for
the obus</p></li>
<li><p>a ‘reset’ part called during fundamental reset as a prereq for link
training. It does the PHY setup for a set of lanes and the dccal.</p></li>
</ul>
<p>The PHY team confirmed there’s no dependency between zcal and the
other reset steps and it can be moved earlier.</p>
</li>
<li><p>npu2-hw-procedures: Fix zcal in mixed opencapi and nvlink mode</p>
<p>The zcal procedure needs to be run once per obus. We keep track of
which obus is already calibrated in an array indexed by the obus
number. However, the obus number is inferred from the brick index,
which works well for nvlink but not for opencapi.</p>
<p>Create an obus_index() function, which, from a device, returns the
correct obus index, irrespective of the device type.</p>
</li>
<li><p>npu2-opencapi: Fix adapter reset when using 2 adapters</p>
<p>If two opencapi adapters are on the same obus, we may try to train the
two links in parallel at boot time, when all the PCI links are being
trained. Both links use the same i2c controller to handle the reset
signal, so some care is needed to make sure resetting one doesn’t
interfere with the reset of the other. We need to keep track of the
current state of the i2c controller (and use locking).</p>
<p>This went mostly unnoticed as you need to have 2 opencapi cards on the
same socket and links tended to train anyway because of the retries.</p>
</li>
<li><p>npu2-opencapi: Extend delay after releasing reset on adapter</p>
<p>Give more time to the FPGA to process the reset signal. The previous
delay, 5ms, is too short for newer adapters with bigger FPGAs. Extend
it to 250ms.
Ultimately, that delay will likely end up being added to the opencapi
specification, but we are not there yet.</p>
</li>
<li><p>npu2-opencapi: ODL should be in reset when enabled</p>
<p>We haven’t hit any problem so far, but from the ODL designer, the ODL
should be in reset when it is enabled.</p>
<p>The ODL remains in reset until we start a fundamental reset to
initiate link training. We still assert and deassert the ODL reset
signal as part of the normal procedure just before training the
link. Asserting is therefore useless at boot, since the ODL is already
in reset, but we keep it as it’s only a scom write and it’s needed
when we reset/retrain from the OS.</p>
</li>
<li><p>npu2-opencapi: Keep ODL and adapter in reset at the same time</p>
<p>Split the function to assert and deassert the reset signal on the ODL,
so that we can keep the ODL in reset while we reset the adapter,
therefore having a window where both sides are in reset.</p>
<p>It is actually not required with our current DLx at boot time, but I
need to split the ODL reset function for the following patch and it
will become useful/required later when we introduce resetting an
opencapi link from the OS.</p>
</li>
<li><p>npu2-opencapi: Setup perf counters to detect CRC errors</p>
<p>It’s possible to set up performance counters for the PLL to detect
various conditions for the links in nvlink or opencapi mode. Since
those counters are currently unused, let’s configure them when an obus
is in opencapi mode to detect CRC errors on the link. Each link has
two counters:
- CRC error detected by the host
- CRC error detected by the DLx (NAK received by the host)</p>
<p>We also dump the counters shortly after the link trains, but they can
be read multiple times through cronus, pdbg or linux. The counters are
configured to be reset after each read.</p>
</li>
</ul>
<p>Since v6.3-rc1:</p>
<ul>
<li><p>opal/hmi: Never trust a cow!</p>
<p>With opencapi, it’s fairly common to trigger HMIs during AFU
development on the FPGA, by not replying in time to an NPU command,
for example. So shift the blame reported by that cow to avoid crowding
my mailbox.</p>
</li>
<li><p>hw/npu2: Dump (more) npu2 registers on link error and HMIs</p>
<p>We were already logging some NPU registers during an HMI. This patch
cleans up a bit how it is done and separates what is global from what
is specific to nvlink or opencapi.</p>
<p>Since we can now receive an error interrupt when an opencapi link goes
down unexpectedly, we also dump the NPU state but we limit it to the
registers of the brick which hit the error.</p>
<p>The list of registers to dump was worked out with the hw team to
allow for proper debugging. For each register, we print the name as
found in the NPU workbook, the scom address and the register value.</p>
</li>
<li><p>hw/npu2: Report errors to the OS if an OpenCAPI brick is fenced</p>
<p>Now that the NPU may report interrupts due to the link going down
unexpectedly, report those errors to the OS when queried by the
‘next_error’ PHB callback.</p>
<p>The hardware doesn’t support recovery of the link when it goes down
unexpectedly. So we report the PHB as dead, so that the OS can log the
proper message, notify the drivers and take the devices down.</p>
</li>
<li><p>hw/npu2: Fix OpenCAPI PE assignment</p>
<p>When we support mixing NVLink and OpenCAPI devices on the same NPU, we’re
going to have to share the same range of 16 PE numbers between NVLink and
OpenCAPI PHBs.</p>
<p>For OpenCAPI devices, PE assignment is only significant for determining
which System Interrupt Log register is used for a particular brick - unlike
NVLink, it doesn’t play any role in determining how links are fenced.</p>
<p>Split the PE range into a lower half which is used for NVLink, and an upper
half that is used for OpenCAPI, with a fixed PE number assigned per brick.</p>
<p>As the PE assignment for OpenCAPI devices is fixed, set the PE once
during device init and then ignore calls to the set_pe() operation.</p>
</li>
<li><p>opal-api: Reserve 2 OPAL API calls for future OpenCAPI LPC use</p>
<p>OpenCAPI Lowest Point of Coherency (LPC) memory is going to require
some extra OPAL calls to set up NPU BARs. These calls will most likely be
called OPAL_NPU_LPC_ALLOC and OPAL_NPU_LPC_RELEASE, we’re not quite ready
to upstream that code yet though.</p>
</li>
</ul>
</section>
<section id="nvlink2">
<h2>NVLINK2<a class="headerlink" href="#nvlink2" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>npu2: Allow ATSD for LPAR other than 0</p>
<p>Each XTS MMIO ATSD# register is accompanied by another register -
XTS MMIO ATSD0 LPARID# - which controls LPID filtering for ATSD
transactions.</p>
<p>When a host system passes a GPU through to a guest, we need to enable
some ATSD for an LPAR. At the moment the host assigns one ATSD to
a NVLink bridge and this maps it to an LPAR when GPU is assigned to
the LPAR. The link number is used for an ATSD index.</p>
<p>ATSD6&amp;7 stay mapped to the host (LPAR=0) all the time which seems to be
acceptable price for the simplicity.</p>
</li>
<li><p>npu2: Add XTS_BDF_MAP wildcard refcount</p>
<p>Currently PID wildcard is programmed into the NPU once and never cleared
up. This works for the bare metal as MSR does not change while the host
OS is running.</p>
<p>However with the device virtualization, we need to keep track of wildcard
entries use and clear them up before switching a GPU from a host to
a guest or vice versa.</p>
<p>This adds refcount to a NPU2, one counter per wildcard entry. The index
is a short lparid (4 bits long) which is allocated in opal_npu_map_lpar()
and should be smaller than NPU2_XTS_BDF_MAP_SIZE (defined as 16).</p>
</li>
</ul>
<p>Since v6.3-rc2:
- npu2: Disable Probe-to-Invalid-Return-Modified-or-Owned snarfing by default</p>
<blockquote>
<div><p>V100 GPUs are known to violate NVLink2 protocol in some cases (one is when
memory was accessed by the CPU and they by GPU using so called block
linear mapping) and issue double probes to NPU which can cope with this
problem only if CONFIG_ENABLE_SNARF_CPM (“disable/enable Probe.I.MO
snarfing a cp_m”) is not set in the CQ_SM Misc Config register #0.
If the bit is set (which is the case today), NPU issues the machine
check stop.</p>
<p>The snarfing feature is designed to detect 2 probes in flight and combine
them into one.</p>
<p>This adds a new “opal-npu2-snarf-cpm” nvram variable which controls
CONFIG_ENABLE_SNARF_CPM for all NVLinks to prevent the machine check
stop from happening.</p>
<p>This disables snarfing by default as otherwise a broken GPU driver can
crash the entire box even when a GPU is passed through to a guest.
This provides a dial to allow regression tests (might be useful for
a bare metal). To enable snarfing, the user needs to run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">nvram</span> <span class="o">-</span><span class="n">p</span> <span class="n">ibm</span><span class="p">,</span><span class="n">skiboot</span> <span class="o">--</span><span class="n">update</span><span class="o">-</span><span class="n">config</span> <span class="n">opal</span><span class="o">-</span><span class="n">npu2</span><span class="o">-</span><span class="n">snarf</span><span class="o">-</span><span class="n">cpm</span><span class="o">=</span><span class="n">enable</span>
</pre></div>
</div>
<p>and reboot the host system.</p>
</div></blockquote>
<ul class="simple">
<li><p>hw/npu2: Show name of opencapi error interrupts</p></li>
</ul>
</section>
<section id="debugging-and-simulation">
<h2>Debugging and simulation<a class="headerlink" href="#debugging-and-simulation" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>external/mambo: Error out if kernel is too large</p>
<p>If you’re trying to boot a gigantic kernel in mambo (which you can
reproduce by building a kernel with CONFIG_MODULES=n) you’ll get
misleading errors like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">WARNING</span><span class="p">:</span> <span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">):</span> <span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">]:</span> <span class="n">Invalid</span><span class="o">/</span><span class="n">unsupported</span> <span class="n">instr</span> <span class="mh">0x00000000</span><span class="p">[</span><span class="n">INVALID</span><span class="p">]</span>
<span class="n">WARNING</span><span class="p">:</span> <span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">):</span>  <span class="n">PC</span><span class="p">(</span><span class="n">EA</span><span class="p">):</span> <span class="mh">0x0000000030000010</span> <span class="n">PC</span><span class="p">(</span><span class="n">RA</span><span class="p">):</span><span class="mh">0x0000000030000010</span> <span class="n">MSR</span><span class="p">:</span> <span class="mh">0x9000000000000000</span> <span class="n">LR</span><span class="p">:</span> <span class="mh">0x0000000000000000</span>
<span class="n">WARNING</span><span class="p">:</span> <span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">):</span>  <span class="n">numInstructions</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">WARNING</span><span class="p">:</span> <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">):</span> <span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">]:</span> <span class="n">Invalid</span><span class="o">/</span><span class="n">unsupported</span> <span class="n">instr</span> <span class="mh">0x00000000</span><span class="p">[</span><span class="n">INVALID</span><span class="p">]</span>
<span class="n">WARNING</span><span class="p">:</span> <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">):</span>  <span class="n">PC</span><span class="p">(</span><span class="n">EA</span><span class="p">):</span> <span class="mh">0x0000000000000E40</span> <span class="n">PC</span><span class="p">(</span><span class="n">RA</span><span class="p">):</span><span class="mh">0x0000000000000E40</span> <span class="n">MSR</span><span class="p">:</span> <span class="mh">0x9000000000000000</span> <span class="n">LR</span><span class="p">:</span> <span class="mh">0x0000000000000000</span>
<span class="n">WARNING</span><span class="p">:</span> <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">):</span>  <span class="n">numInstructions</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">WARNING</span><span class="p">:</span> <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">):</span> <span class="n">Interrupt</span> <span class="n">to</span> <span class="mh">0x0000000000000E40</span> <span class="kn">from</span> <span class="mh">0x0000000000000E40</span>
<span class="n">INFO</span><span class="p">:</span> <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">):</span> <span class="o">**</span> <span class="n">Execution</span> <span class="n">stopped</span><span class="p">:</span> <span class="n">Continuous</span> <span class="n">Interrupt</span><span class="p">,</span> <span class="n">Instruction</span> <span class="n">caused</span> <span class="n">exception</span><span class="p">,</span>  <span class="o">**</span>
</pre></div>
</div>
<p>So add an error to skiboot.tcl to warn the user before this happens.
Making PAYLOAD_ADDR further back is one way to do this but if there’s a
less gross way to generally work around this very niche problem, I can
suggest that instead.</p>
</li>
<li><p>external/mambo: Populate kernel-base-address in the DT</p>
<p>skiboot.tcl defines PAYLOAD_ADDR as 0x20000000, which is the default in
skiboot.  This is also the default in skiboot unless kernel-base-address
is set in the device tree.</p>
<p>If you change PAYLOAD_ADDR to something else for mambo, skiboot won’t
see it because it doesn’t set that DT property, so fix it so that it does.</p>
</li>
<li><p>external/mambo: allow CPU targeting for most debug utils</p>
<p>Debug util functions target CPU 0:0:0 by default Some can be
overidden explicitly per invocation, and others can’t at all.
Even for those that can be overidden, it is a pain to type
them out when you’re debugging a particular thread.</p>
<p>Provide a new ‘target’ function that allows the default CPU
target to be changed. Wire that up that default to all other utils.
Provide a new ‘S’ step command which only steps the target CPU.</p>
</li>
<li><p>qemu: bt device isn’t always hanging off /</p>
<p>Just use the normal for_each_compatible instead.</p>
<p>Otherwise in the qemu model as executed by op-test,
we wouldn’t go down the astbmc_init() path, thus not having flash.</p>
</li>
<li><p>devicetree: Add p9-simics.dts</p>
<p>Add a p9-based devicetree that’s suitable for use with Simics.</p>
</li>
<li><p>devicetree: Move power9-phb4.dts</p>
<p>Clean up the formatting of power9-phb4.dts and move it to
external/devicetree/p9.dts. This sets us up to include it as the basis
for other trees.</p>
</li>
<li><p>devicetree: Add nx node to power9-phb4.dts</p>
<p>A (non-qemu) p9 without an nx node will assert in p9_darn_init():</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dt_for_each_compatible(dt_root, nx, &quot;ibm,power9-nx&quot;)
        break;
if (!nx) {
        if (!dt_node_is_compatible(dt_root, &quot;qemu,powernv&quot;))
              assert(nx);
        return;
}
</pre></div>
</div>
<p>Since NX is this essential, add it to the device tree.</p>
</li>
<li><p>devicetree: Fix typo in power9-phb4.dts</p>
<p>Change “impi” to “ipmi”.</p>
</li>
<li><p>devicetree: Fix syntax error in power9-phb4.dts</p>
<p>Remove the extra space causing this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Error</span><span class="p">:</span> <span class="n">power9</span><span class="o">-</span><span class="n">phb4</span><span class="o">.</span><span class="n">dts</span><span class="p">:</span><span class="mf">156.15</span><span class="o">-</span><span class="mi">16</span> <span class="n">syntax</span> <span class="n">error</span>
<span class="n">FATAL</span> <span class="n">ERROR</span><span class="p">:</span> <span class="n">Unable</span> <span class="n">to</span> <span class="n">parse</span> <span class="nb">input</span> <span class="n">tree</span>
</pre></div>
</div>
</li>
<li><p>core/init: enable machine check on secondaries</p>
<p>Secondary CPUs currently run with MSR[ME]=0 during boot, whih means
if they take a machine check, the system will checkstop.</p>
<p>Enable ME where possible and allow them to print registers.</p>
</li>
</ul>
</section>
<section id="utilities">
<h2>Utilities<a class="headerlink" href="#utilities" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>pflash: Don’t try update RO ToC</p>
<p>In the future it’s likely the ToC will be marked as read-only. Don’t
error out by assuming its writable.</p>
</li>
<li><p>pflash: Support encoding/decoding ECC’d partitions</p>
<p>With the new –ecc option, pflash can add/remove ECC when
reading/writing flash partitions protected by ECC.</p>
<p>This is <em>not</em> flawless with current PNORs out in the wild though, as
they do not typically fill the whole partition with valid ECC data, so
you have to know how big the valid ECC’d data is and specify the size
manually. Note that for some partitions this is pratically impossible
without knowing the details of the content of the partition.</p>
<p>A future patch is likely to introduce an option to “stop reading data
when ECC starts failing and assume everything is okay rather than error
out” to support reading the “valid” data from existing PNOR images.</p>
</li>
</ul>
<p>Since v6.3-rc2:</p>
<ul class="simple">
<li><p>opal-prd: Fix memory leak in is-fsp-system check</p></li>
<li><p>opal-prd: Check malloc return value</p></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">skiboot-6.3</a><ul>
<li><a class="reference internal" href="#new-features">New Features</a></li>
<li><a class="reference internal" href="#deprecated-removed-features">Deprecated/Removed Features</a></li>
<li><a class="reference internal" href="#general">General</a></li>
<li><a class="reference internal" href="#ibm-fsp-based-platforms">IBM FSP based platforms</a></li>
<li><a class="reference internal" href="#hiomap">HIOMAP</a></li>
<li><a class="reference internal" href="#power8">POWER8</a><ul>
<li><a class="reference internal" href="#p8dtu-platform">p8dtu Platform</a></li>
<li><a class="reference internal" href="#vesnin-platform">Vesnin Platform</a></li>
</ul>
</li>
<li><a class="reference internal" href="#power9">POWER9</a><ul>
<li><a class="reference internal" href="#capi2">CAPI2</a></li>
<li><a class="reference internal" href="#witherspoon-platform">Witherspoon Platform</a></li>
<li><a class="reference internal" href="#zaius-platform">Zaius Platform</a></li>
<li><a class="reference internal" href="#p9dsu-platform">p9dsu platform</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pcie">PCIe</a></li>
<li><a class="reference internal" href="#opencapi">OpenCAPI</a></li>
<li><a class="reference internal" href="#nvlink2">NVLINK2</a></li>
<li><a class="reference internal" href="#debugging-and-simulation">Debugging and simulation</a></li>
<li><a class="reference internal" href="#utilities">Utilities</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="skiboot-6.2.4.html"
                        title="previous chapter">skiboot-6.2.4</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="skiboot-6.3-rc1.html"
                        title="next chapter">skiboot-6.3-rc1</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/release-notes/skiboot-6.3.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="skiboot-6.3-rc1.html" title="skiboot-6.3-rc1"
             >next</a> |</li>
        <li class="right" >
          <a href="skiboot-6.2.4.html" title="skiboot-6.2.4"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">skiboot 326a466
 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Release Notes</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">skiboot-6.3</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2017, IBM, others.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.2.
    </div>
  </body>
</html>